{"version":3,"file":"CryptoPaymentService.js","sourceRoot":"src/","sources":["services/webhook/CryptoPaymentService.ts"],"names":[],"mappings":";;;;AAAA,iCAA8C;AAE9C,uCAAmD;AAG5C,IAAM,oBAAoB,GAA1B,MAAM,oBAAoB;IAE/B,SAAS,CAAuB;IACf,gBAAgB,GAAa;QAC5C,kBAAkB;QAClB,eAAe;QACf,gBAAgB;QAChB,iBAAiB;KAClB,CAAC;IAEF,gBAAe,CAAC;IAEhB,KAAK,CAAC,WAAW,CAAC,KAAU;QAC1B,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;YAC/C,OAAO,IAAI,CAAC;SACb;QAED,MAAM,cAAc,GAAQ,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC;QAC7C,MAAM,KAAK,GAAQ,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;YAC9C,sBAAsB,EAAE,cAAc,CAAC,IAAI;SAC5C,CAAC,CAAC;QAEH,IAAI,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YAC7C,OAAO,KAAK,CAAC;SACd;QAED,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,KAAK,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE;YAChD,OAAO,IAAI,CAAC;SACb;QAED,IAAI;YACF,QAAQ,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE;gBACxB,KAAK,kBAAkB;oBACrB,2DAA2D;oBAC3D,kDAAkD;oBAClD,sBAAsB;oBACtB,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAC5B,EAAE,oBAAoB,EAAE,cAAc,CAAC,EAAE,EAAE,EAC3C;wBACE,IAAI,EAAE;4BACJ,gBAAgB,EAAE,qBAAa,CAAC,SAAS;4BACzC,OAAO,EAAE,cAAc;yBACxB;qBACF,CACF,CAAC;oBACF,MAAM;gBACR,KAAK,eAAe;oBAClB,wBAAwB;oBACxB,+BAA+B;oBAC/B,sBAAsB;oBACtB,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAC5B,EAAE,oBAAoB,EAAE,cAAc,CAAC,EAAE,EAAE,EAC3C;wBACE,IAAI,EAAE;4BACJ,gBAAgB,EAAE,IAAI;4BACtB,OAAO,EAAE,IAAI;yBACd;qBACF,CACF,CAAC;oBACF,MAAM;gBACR,KAAK,gBAAgB;oBACnB,eAAe;oBACf,MAAM;gBACR,KAAK,iBAAiB;oBACpB,eAAe;oBACf,MAAM;gBACR;oBACE,OAAO,CAAC,GAAG,CAAC,qBAAqB,CAAC,CAAC;aACtC;YACD,OAAO,IAAI,CAAC;SACb;QAAC,OAAO,KAAK,EAAE;YACd,OAAO,KAAK,CAAC;SACd;IACH,CAAC;CACF,CAAA;AA1EY,oDAAoB;AAE/B;IADC,IAAA,WAAM,EAAC,aAAK,CAAC;;uDACkB;+BAFrB,oBAAoB;IADhC,IAAA,eAAU,GAAE;;GACA,oBAAoB,CA0EhC","sourcesContent":["import { Injectable, Inject } from \"@tsed/di\";\nimport { MongooseModel } from \"@tsed/mongoose\";\nimport { Order, PaymentStatus } from \"../../types\";\n\n@Injectable()\nexport class CryptoPaymentService {\n  @Inject(Order)\n  orderBook: MongooseModel<Order>;\n  private readonly recognisedEvents: string[] = [\n    \"charge:confirmed\",\n    \"charge:failed\",\n    \"charge:delayed\",\n    \"charge:resolved\"\n  ];\n\n  constructor() {}\n\n  async handleEvent(event: any): Promise<boolean> {\n    if (!this.recognisedEvents.includes(event.type)) {\n      return true;\n    }\n\n    const sessionInEvent: any = event.event.data;\n    const order: any = await this.orderBook.findOne({\n      \"payment.session.code\": sessionInEvent.code\n    });\n\n    if (!order || !order.payment || !order.status) {\n      return false;\n    }\n\n    if (order.payment.lastEventId === event.event.id) {\n      return true;\n    }\n\n    try {\n      switch (event.event.type) {\n        case \"charge:confirmed\":\n          //order.payment.session.timeline = sessionInEvent.timeline;\n          // order.status.payment = PaymentStatus.completed;\n          // await order.save();\n          await this.orderBook.updateOne(\n            { \"payment.session.id\": sessionInEvent.id },\n            {\n              $set: {\n                \"status.payment\": PaymentStatus.completed,\n                payment: sessionInEvent\n              }\n            }\n          );\n          break;\n        case \"charge:failed\":\n          // order.payment = null;\n          // order.status.payment = null;\n          // await order.save();\n          await this.orderBook.updateOne(\n            { \"payment.session.id\": sessionInEvent.id },\n            {\n              $set: {\n                \"status.payment\": null,\n                payment: null\n              }\n            }\n          );\n          break;\n        case \"charge:delayed\":\n          // notify admin\n          break;\n        case \"charge:resolved\":\n          // notify admin\n          break;\n        default:\n          console.log(\"Event not relevant.\");\n      }\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n}\n"]}